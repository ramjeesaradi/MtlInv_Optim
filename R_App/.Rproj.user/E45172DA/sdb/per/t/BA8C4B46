{
    "collab_server" : "",
    "contents" : "constrobjfn <- function(sol,params){\n  constr <- reqMet(sol,params)\n  obj1 <- invUtilSheet(sol,params)\n  obj2 <- invUtilCoil(sol,params)\n  \n  obj <- c(obj1,constr)\n  fitness <- sqrt(sum(obj^2))\n  # fitness <- constr*fitness\n  return(fitness)\n}\n\nobjfn <- function(sol,params){\n  obj1 <- invUtil(sol,params)\n  # obj2 <- wastemin(sol,params)\n  # obj3 <- prmax(sol,params)\n  # obj4 <- expensmin(sol,params)\n  obj <- c(obj1)\n  fitness <- sqrt(sum(obj^2))\n  return(fitness)\n}\nreqMet <- function(sol,params){\n  req <- t(params$sfg0[,ncol(sfg0)])\n  produce <- sol %*% t(params$sfg0[,-ncol(sfg0)])\n  satis <- sum((produce-req)^2)\n  return(satis)\n}\n\ninvUtilSheet <- function(sol,params){\n  cost <- sol %*% t(params$Sheetstk)\n  cost <- sum(cost)/length(sol)\n  return(cost)\n  \n}\n\ninvUtilCoil <- function(sol,params){\n  cost <- sol %*% t(params$Coilstk)\n  cost <- sum(cost)/length(sol)\n  return(cost)\n  \n}\n\nwastemin <- function(sol,params){\n  cost <- sol %*%  t(params$sfgwst)\n  return(sum(cost^2))\n}\n\nprmax <- function(sol,params){\n  cost <- sol %*%  t(params$sfgpr)\n  return(sum(cost^2))\n}\n\ngetParams <- function(wastage.threshold,rmpart1,params) {\n  # params <- list()\n  params$wastage.threshold <- wastage.threshold\n  #Take the req for the month in question\n  params$message <- \"\"\n  #Generate Matrices\n  #Matrix for Calculating the parts produced\n  sfg <- cast(rmpart1,SFG + Req ~ SFG_+RM_+con_+RM.Length+RM.Breadth+Batch_+inStock,\n              value = \"Qnty\",\n              fun.aggregate = max,\n              fill=0)\n  \n  pairnms <- names(sfg)[-c(1,2)]\n  params$pairnms <- pairnms\n  # pairs <- lapply(strsplit(pairnms, \"_\"), function (x) x)\n  # # ifelse(length(x)==4,c(x,\"\"),x[c(1,2,4,5,3)])\n\n  \n  #Wastage percentage\n  wstprct <- cast(rmpart1,SFG ~ SFG_+RM_+con_+RM.Length+RM.Breadth+Batch_+inStock,\n                  value = \"wastage\",\n                  fun.aggregate = max,\n                  fill=0)\n  params$wstprct <- wstprct[,pairnms]\n  #Stock Matrix after combinig all whare houses\n  Sheetstk <- cast(rmpart1,RM+RM.Length_+RM.Breadth_+Batch ~ SFG_+RM_+con_+RM.Length+RM.Breadth+Batch_+inStock,\n                   value = \"SheetStock\",\n                   fun.aggregate = function (x) ifelse(sum(x)==0,yes = 0,no = 1/max(x)),\n                   fill=0)\n  \n  params$Sheetstk <- Sheetstk[,c(pairnms)]\n  Coilstk <- cast(rmpart1,con+Batch ~ SFG_+RM_+con_+RM.Length+RM.Breadth+Batch_+inStock,\n                  value = \"CoilStock\",\n                  fun.aggregate = function (x) ifelse(sum(x)==0,yes = 0,no = 1/max(x)),\n                  fill=0)\n  \n  params$Coilstk <- Coilstk[pairnms]\n  \n  Cost <- cast(rmpart1,. ~ SFG_+RM_+con_+RM.Length+RM.Breadth+Batch_+inStock,\n               value = \"totalCost\",\n               fun.aggregate = max,\n               fill=0)\n  \n  params$Cost <- Cost[pairnms]\n  \n  Cost1 <- cast(rmpart1,. ~ SFG_+RM_+con_+RM.Length+RM.Breadth+Batch_+inStock,\n               value = \"cost1\",\n               fun.aggregate = max,\n               fill=0)\n  params$Cost1 <- Cost1[pairnms]\n  \n  #prempting wastage for one to one mapped parts\n  wastage.threshold <- ifelse(max(rmpart1$Priority)>0,99.9,wastage.threshold)\n  \n  lhs <- rbind(sfg[,pairnms], Sheetstk[,pairnms],Coilstk[,pairnms])\n  # lhs <- cbind(lhs,rep(0,nrow(lhs)))\n  lhs[is.na(lhs)]<- 0\n  params$lhs <- lhs\n  rhs <- c(sfg[,2],rep(1,nrow(Sheetstk)),rep(1,nrow(Coilstk)))\n  rhs[is.na(rhs)]<- 0\n  params$rhs <-rhs\n  cond <- c(rep(\"==\",nrow(sfg)),rep(\"<=\",nrow(Sheetstk)),rep(\"<=\",nrow(Coilstk)))\n  params$cond <- cond\n  return(params)\n}\n\nrunOptim <- function(params) {\n  if(length(params$pairnms)==1){Cost <- as.vector((params$Cost))}else{Cost <-as.vector(t(params$Cost))}\n  params$Cost$N <- 0\n  solObj <- lp(direction = \"min\", \n               objective.in = Cost,\n               const.mat = params$lhs\n               ,const.dir = params$cond\n               ,const.rhs = params$rhs\n               )\n  \n  return(solObj)\n}",
    "created" : 1464609410344.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4204881665",
    "id" : "BA8C4B46",
    "lastKnownWriteTime" : 1464695587,
    "last_content_update" : 1464695587180,
    "path" : "~/workspace/Veero Optim/R_App/optimObj.R",
    "project_path" : "optimObj.R",
    "properties" : {
        "docOutlineSize" : "108",
        "docOutlineVisible" : "1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}